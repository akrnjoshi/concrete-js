<!DOCTYPE html>
<html lang="en">
<head>
  <title>concrete-js examples</title>
  <meta charset='UTF-8'>

  <link rel="stylesheet" href="bootstrap-3.2.0/css/bootstrap.css"/>
  <link rel="stylesheet" href="bootstrap-3.2.0/css/bootstrap-theme.css"/>
  <link rel="stylesheet" href="examples.css"/>

  <script src="jquery-1.11.1.js"></script>
  <script src="bootstrap-3.2.0/js/bootstrap.js"></script>

  <script src="thrift.js"></script>
  <script src="concrete.js"></script>

  <style>
  .character {
    display: inline-block;
    border-bottom: 10px solid #F4F4F4;
  }
  .character_gap {
    cursor: pointer;
    display: inline-block;
    min-width: 1em;
  }
  .connected_characters {
    background-color: yellow;
    border-bottom: 10px solid #CCCCCC;
  }
  </style>

  <script>
  // We do not want any of the .character_gap spans to have a tabindex of 0, as
  // a tabindex of 0 is treated differently than a tabindex of 1 or greater:
  //   https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
  // We use a positive offset, so that the character in the Communication with
  // character index 0 is not assigned a tabindex of 0.
  $.fn.TOKENIZE_TABINDEX_OFFSET = 10;

  /**
   *
   */
  $.fn.manualTokenizationWidget = function(sentence) {
    function toggleHighlightingWhenSpacePressed(event) {
      var el = $(this);
      if (el.hasClass('character_gap')) {
        if (event.which === 32) {
          var prevEl = el.prev();
          var nextEl = el.next();

          if (el.hasClass('connected_characters')) {
            el.removeClass('connected_characters');
            if (!el.prev().prev('.character_gap').hasClass('connected_characters')) {
              prevEl.removeClass('connected_characters');
            }
            if (!el.next().next('.character_gap').hasClass('connected_characters')) {
              nextEl.removeClass('connected_characters');
            }
          }
          else {
            el.addClass('connected_characters');
            prevEl.addClass('connected_characters');
            nextEl.addClass('connected_characters');
          }
        }
      }
    }

    var tokenizeSentenceDiv = $('<div>').addClass('manual_tokenization')
                                        .data('sentence', sentence);
    for (var i = sentence.textSpan.start; i < sentence.textSpan.ending; i++) {
      tokenizeSentenceDiv.append(
        $('<span>').addClass('character')
                   .text(sentence.section.comm.text.substring(i, i+1)));
      if (i < sentence.textSpan.ending-1) {
        tokenizeSentenceDiv.append(
          $('<span>').addClass('character_gap')
                     .attr('tabindex', $.fn.TOKENIZE_TABINDEX_OFFSET + i)
                     .html('&nbsp; ')
                     .keydown(toggleHighlightingWhenSpacePressed));
      }
    }
    this.append(tokenizeSentenceDiv);

    return this;
  };

  /**
   *
   */
  $.fn.getManualTokenization = function() {
    var tokenizeSentenceDiv;
    if (this.hasClass('manual_tokenization')) {
      tokenizeSentenceDiv = this;
    }
    else {
      tokenizeSentenceDiv = this.find('.manual_tokenization').first();
    }
    var sentence = tokenizeSentenceDiv.data('sentence');

    var joinedTokenIndices = [];
    tokenizeSentenceDiv.find('.character_gap.connected_characters').each(function() {
      joinedTokenIndices.push(parseInt($(this).attr('tabindex')) - $.fn.TOKENIZE_TABINDEX_OFFSET);
    });

    var tokenization = new Tokenization();
    tokenization.kind = TokenizationKind.TOKEN_LIST;
    tokenization.metadata = new AnnotationMetadata();
    tokenization.metadata.timestamp = Math.floor(Date.now()/1000);
    tokenization.metadata.tool = 'concrete.js - getTokenizedSentence()';
    tokenization.tokenList = new TokenList();
    tokenization.tokenList.tokenList = [];
    tokenization.uuid = concrete.util.generateUUID();

    for (var i = sentence.textSpan.start; i < sentence.textSpan.ending-1; i++) {
      var textSpan = new TextSpan();
      textSpan.start = i;
      while (joinedTokenIndices.includes(i)) {
        i += 1;
      }
      textSpan.ending = i+1;
      var token = new Token();
      token.text = sentence.section.comm.text.substring(textSpan.start, textSpan.ending);
      token.textSpan = textSpan;
      token.tokenIndex = tokenization.tokenList.tokenList.length;
      tokenization.tokenList.tokenList.push(token);
    }

    return tokenization;
  };

  function saveManuallyTokenizedCommunication() {
    var comm = $('#sentence_list').find('.manual_tokenization').first().data('sentence').section.comm;
    $('#sentence_list').find('.manual_tokenization').each(function() {
      var sentence = $(this).data('sentence');
      var tokenization = $(this).getManualTokenization();
      sentence.tokenization = tokenization;
    });

    var transport = new Thrift.Transport("/store_http_endpoint/");
    var protocol = new Thrift.TJSONProtocol(transport);
    var storeClient = new StoreCommunicationServiceClient(protocol);
    try {
      storeClient.store(comm);
    }
    catch (e) {
      // HACK: For some reason, the Thrift-generated JavaScript is expecting some sort of return
      //       value for StoreCommunicationService.store(), even though the function has a void
      //       return type.  We ignore this particular error message.
      //
      //       The concrete.js call stack is store() -> recv_store() -> readMessageBegin(), and
      //       readMessageBegin() tries to call JSON.parse() on the empty string, "".
      if (!(e instanceof SyntaxError && e.toString() === "SyntaxError: JSON Parse error: Unexpected EOF")) {
        throw e;
      }
    }
  }

  $(document).ready(function() {
    $.getJSON('weibo.comm.json', function(commJSONData) {
      var comm = new Communication();
      comm.initFromTJSONProtocolObject(commJSONData);
      comm.addInternalReferences();

      var sentences = comm.getSentencesAsList();

      for (i = 0 ; i < sentences.length; i++) {
        var sentenceDiv = $('<div>').addClass('communication_container');
        sentenceDiv.manualTokenizationWidget(sentences[i]);
        $('#sentence_list').append(sentenceDiv);
      }

      $('#initial_focus').attr('tabindex', 1).focus();

      $('#save_button').click(saveManuallyTokenizedCommunication);
    });
  });
  </script>
</head>
<body>
  <div class="container-fluid">

    <button id="save_button" type="button" class="btn btn-default">Save</button>

    <div style="padding-top: 2em;">
      <h2>Manual tokenization UI example</h2>
      <div>
        <p>
          Press tab (or shift-tab) to move the focus between two characters.

          Press the space key to connect merge characters into multi-character tokens.
        </p>
      </div>
      <div>
        <span id="initial_focus"></span>
        <div id="sentence_list"></div>
      </div>
    </div>

  </div>
</body>
</html>

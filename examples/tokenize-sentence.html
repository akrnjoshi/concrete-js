<!DOCTYPE html>
<html lang="en">
<head>
  <title>concrete-js examples</title>
  <meta charset='UTF-8'>

  <link rel="stylesheet" href="bootstrap-3.2.0/css/bootstrap.css"/>
  <link rel="stylesheet" href="bootstrap-3.2.0/css/bootstrap-theme.css"/>
  <link rel="stylesheet" href="examples.css"/>

  <script src="jquery-1.11.1.js"></script>
  <script src="bootstrap-3.2.0/js/bootstrap.js"></script>

  <script src="thrift.js"></script>
  <script src="concrete.js"></script>

  <style>
  .character {
    display: inline-block;
    border-bottom: 10px solid #F4F4F4;
  }
  .character_gap {
    cursor: pointer;
    display: inline-block;
    min-width: 1em;
  }
  .connected_characters {
    background-color: yellow;
    border-bottom: 10px solid #CCCCCC;
  }

  .communication_id_item {
    display: inline-block;
    padding: 0.5em;
  }
  </style>

  <script>
  /**
   * @function external:"jQuery.fn".manualTokenizationWidget
   * @param {Sentence} sentence
   * @returns {external:jQuery_Object}
   */
  $.fn.manualTokenizationWidget = function(sentence) {

    function manualTokenizationKeyboardNavigation(event) {
      var el = $(this);
      if (el.hasClass('character_gap')) {
        var characterGapEls;
        var characterGapIndex;

        if (event.which === 32) { // Space
          var prevEl = el.prev();
          var nextEl = el.next();

          if (el.hasClass('connected_characters')) {
            el.removeClass('connected_characters');
            if (!el.prev().prev('.character_gap').hasClass('connected_characters')) {
              prevEl.removeClass('connected_characters');
            }
            if (!el.next().next('.character_gap').hasClass('connected_characters')) {
              nextEl.removeClass('connected_characters');
            }
          }
          else {
            el.addClass('connected_characters');
            prevEl.addClass('connected_characters');
            nextEl.addClass('connected_characters');
          }
        }
        else if (event.which === 37) { // Left arrow
          if (el.prev().prev('.character_gap').length !== 0) {
            // Move cursor to left
            el.prev().prev('.character_gap').focus();
          }
          else {
            characterGapEls = $('.character_gap');
            characterGapIndex = characterGapEls.index(el);
            if (characterGapIndex === 0) {
              // Wraparound
              characterGapEls.last().focus();
            }
            else {
              characterGapEls.eq(characterGapIndex-1).focus();
            }
          }
        }
        else if (event.which === 39) { // Right arrow
          if (el.next().next('.character_gap').length !== 0) {
            // Move cursor to right
            el.next().next('.character_gap').focus();
          }
          else {
            characterGapEls = $('.character_gap');
            characterGapIndex = characterGapEls.index(el);
            if (characterGapIndex >= characterGapEls.length-1) {
              // Wraparound
              characterGapEls.first().focus();
            }
            else {
              characterGapEls.eq(characterGapIndex+1).focus();
            }
          }
        }
        else if (event.which === 38) { // Up arrow
          characterGapEls = $('.character_gap');
          characterGapIndex = characterGapEls.index(el);
          if (characterGapIndex === 0 ||
              characterGapEls.index(el.siblings('.character_gap').first()) === 0)
          {
            // Wraparound
            characterGapEls.eq(characterGapEls.length-1).siblings('.character_gap').first().focus();
          }
          else {
            var firstInSentenceIndex = characterGapEls.index(el.siblings('.character_gap').first());
            if (characterGapEls.index(el) < firstInSentenceIndex) {
              // All siblings are to right of current element
              characterGapEls.eq(characterGapEls.index(el)-1).siblings('.character_gap').first().focus();
            }
            else {
              characterGapEls.eq(firstInSentenceIndex-1).siblings('.character_gap').first().focus();
            }
          }
        }
        else if (event.which === 40) { // Down arrow
          characterGapEls = $('.character_gap');
          var lastInSentence = el.siblings('.character_gap').last();
          var lastInSentenceIndex = characterGapEls.index(lastInSentence);
          if (lastInSentenceIndex === characterGapEls.length-1) {
            // Wraparound
            characterGapEls.first().focus();
          }
          else {
            if (characterGapEls.index(el) > lastInSentenceIndex) {
              // All siblings are to left of current element
              characterGapEls.eq(characterGapEls.index(el)+1).focus();
            }
            else {
              characterGapEls.eq(lastInSentenceIndex+1).focus();
            }
          }
        }
      }
    }

    // We do not want any of the .character_gap spans to have a tabindex of 0, as
    // a tabindex of 0 is treated differently than a tabindex of 1 or greater:
    //   https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
    // We use a positive offset, so that the character in the Communication with
    // character index 0 is not assigned a tabindex of 0.
    var TOKENIZE_TABINDEX_OFFSET = 10;

    var tokenizeSentenceDiv = $('<div>').addClass('manual_tokenization')
                                        .data('sentence', sentence);
    for (var i = sentence.textSpan.start; i < sentence.textSpan.ending; i++) {
      tokenizeSentenceDiv.append(
        $('<span>').addClass('character')
                   .text(sentence.section.comm.text.substring(i, i+1)));
      if (i < sentence.textSpan.ending-1) {
        tokenizeSentenceDiv.append(
          $('<span>').addClass('character_gap')
                     .attr('tabindex', TOKENIZE_TABINDEX_OFFSET + i)
                     .data('tokenIndex', i)
                     .html('&nbsp; ')
                     .keydown(manualTokenizationKeyboardNavigation));
      }
    }
    this.append(tokenizeSentenceDiv);

    return this;
  };

  /**
   * @function external:"jQuery.fn".getManualTokenization
   * @param {Sentence} sentence
   * @returns {external:jQuery_Object}
   */
  $.fn.getManualTokenization = function() {
    var tokenizeSentenceDiv;
    if (this.hasClass('manual_tokenization')) {
      tokenizeSentenceDiv = this;
    }
    else {
      tokenizeSentenceDiv = this.find('.manual_tokenization').first();
    }
    var sentence = tokenizeSentenceDiv.data('sentence');

    var joinedTokenIndices = [];
    tokenizeSentenceDiv.find('.character_gap.connected_characters').each(function() {
      joinedTokenIndices.push($(this).data('tokenIndex'));
    });

    var tokenization = new Tokenization();
    tokenization.kind = TokenizationKind.TOKEN_LIST;
    tokenization.metadata = new AnnotationMetadata();
    tokenization.metadata.timestamp = Math.floor(Date.now()/1000);
    tokenization.metadata.tool = 'concrete.js - getManualTokenization()';
    tokenization.tokenList = new TokenList();
    tokenization.tokenList.tokenList = [];
    tokenization.uuid = concrete.util.generateUUID();

    for (var i = sentence.textSpan.start; i < sentence.textSpan.ending-1; i++) {
      var textSpan = new TextSpan();
      textSpan.start = i;
      while (joinedTokenIndices.includes(i)) {
        i += 1;
      }
      textSpan.ending = i+1;
      var token = new Token();
      token.text = sentence.section.comm.text.substring(textSpan.start, textSpan.ending);
      token.textSpan = textSpan;
      token.tokenIndex = tokenization.tokenList.tokenList.length;
      tokenization.tokenList.tokenList.push(token);
    }

    return tokenization;
  };

  function displayErrorMessage(message) {
    $('#error_message_text').text(message);
    $('#error_message_div').show();
  }

  function renderSentences(comm) {
    comm.addInternalReferences();

    var sentences = comm.getSentencesAsList();

    for (i = 0 ; i < sentences.length; i++) {
      var sentenceDiv = $('<div>').addClass('communication_container');
      sentenceDiv.manualTokenizationWidget(sentences[i]);
      $('#sentence_list').append(sentenceDiv);
    }
  }

  function saveManuallyTokenizedCommunication() {
    var comm = $('#sentence_list').find('.manual_tokenization').first().data('sentence').section.comm;
    $('#sentence_list').find('.manual_tokenization').each(function() {
      var sentence = $(this).data('sentence');
      var tokenization = $(this).getManualTokenization();
      sentence.tokenization = tokenization;
    });

    var transport = new Thrift.Transport("/store_http_endpoint/");
    var protocol = new Thrift.TJSONProtocol(transport);
    var storeClient = new StoreCommunicationServiceClient(protocol);
    storeClient.store(comm);
  }

  $(document).ready(function() {
    var transport = new Thrift.Transport("/fetch_http_endpoint/");
    var protocol = new Thrift.TJSONProtocol(transport);
    var fetchClient = new FetchCommunicationServiceClient(protocol);

    var fetchAvailable = false;
    try {
      fetchClient.alive();
      fetchAvailable = true;
    }
    catch (e) {
      // If Fetch is unavailable, ignore expected exception
      if (e !== "encountered a unknown request status: 0") {
        throw e;
      }
    }

    if (fetchAvailable) {
      $('#document_list_button').show();

      var commID = concrete.util.getURLParameter('id');

      if (commID) {
        var fetchRequest = new FetchRequest({communicationIds: [commID]});
        var fetchResult = fetchClient.fetch(fetchRequest);
        comm = fetchResult.communications[0];
        if (comm) {
          renderSentences(comm);
        }
        else {
          displayErrorMessage('Unable to Fetch Communication with ID "' + commID + '"');
        }
      }
      else {
        // Display list of Communication IDs
        var communicationIDs = fetchClient.getCommunicationIDs(0, fetchClient.getCommunicationCount());
        for (var i = 0; i < communicationIDs.length; i++) {
          $('#communication_id_list').append(
            $('<span>').addClass('communication_id_item')
                       .append(
                         $('<a>').attr('href', '?id=' + communicationIDs[i])
                                 .text(communicationIDs[i])));
        }
      }

    }
    else {
      // If Fetch server is unavailable, retrieve JSON file from current directory
      $.getJSON('weibo.comm.json', function(commJSONData) {
        var comm = new Communication();
        comm.initFromTJSONProtocolObject(commJSONData);
        renderSentences(comm);
      });
    }

    $('#initial_focus').attr('tabindex', 1).focus();
    $('#save_button').click(saveManuallyTokenizedCommunication);
  });
  </script>
</head>
<body>
  <div class="container-fluid">
    <div style="padding-top: 1em;">
      <button id="save_button" type="button" class="btn btn-default">Save</button>
      <a id="document_list_button" type="button" class="btn btn-default" href="?" style="display: none;">
        Document List
      </a>
    </div>

    <div id="error_message_div" class="alert alert-danger" style="display: none; margin-top: 1em;">
      <span class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></span>
      <span id="error_message_text"></span>
    </div>

    <div style="padding-top: 1em;">
      <h2>Manual tokenization UI example</h2>
      <div>
        <p>
          Use tab, shift-tab, or the arrow keys to move the focus between two characters.

          Press the space key to connect characters into multi-character tokens.
        </p>
      </div>
      <div>
        <span id="initial_focus"></span>
        <div id="sentence_list"></div>
      </div>
    </div>

    <hr />

    <div id="communication_id_list"></div>
  </div>
</body>
</html>
